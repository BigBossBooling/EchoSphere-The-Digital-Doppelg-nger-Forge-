# Phase 1: User Data Ingestion Module (UDIM) - API Specifications

This document provides the API specifications for the User Data Ingestion Module (UDIM) in EchoSphere's Phase 1. These APIs cover user-facing interactions for data upload and third-party connections, as well as internal service-to-service communications.

**General API Design Principles:**

*   **Statelessness:** APIs are designed to be stateless; each request contains all necessary information for processing.
*   **Idempotency:** Mutating operations (POST, PUT, DELETE) should be designed to be idempotent where feasible, allowing safe retries.
*   **Clear Error Messages:** Errors are returned with a consistent JSON structure:
    ```json
    {
      "error": {
        "code": <integer_http_status_code>,
        "message": "<human_readable_error_message>",
        "details": "<optional_specific_error_details_or_field_violations>"
      }
    }
    ```
*   **Security:** All communication MUST use HTTPS. Robust authentication and authorization mechanisms are specified per endpoint. Input validation is performed on all requests.
*   **Versioning:** All API endpoints are versioned (e.g., `/v1/`).
*   **Authentication:** User-facing APIs primarily use OAuth 2.0 Bearer Tokens. Internal APIs use secure service-to-service authentication (e.g., mTLS or signed JWTs).

---

## I. External APIs (User-Facing & Third-Party Data Source Integrations)

### 1. Direct Data Upload API

Allows authenticated users to upload raw data files directly to EchoSphere for persona processing.

#### Endpoint: `POST /v1/users/{userID}/data/upload`

*   **Description:** Uploads a raw data file. The request is processed asynchronously.
*   **Authentication:** OAuth 2.0 Bearer Token (`Authorization: Bearer <user_access_token>`). The token must grant a scope like `data:upload`.
*   **Path Parameters:**
    *   `userID` (UUID, required): The ID of the user uploading the data. Must match the `userID` associated with the Bearer Token.
*   **Request Headers:**
    *   `Authorization: Bearer <user_access_token>`
    *   `Content-Type: multipart/form-data`
*   **Form Data:**
    *   `file` (File, required): The raw data file being uploaded.
    *   `sourceDescription` (String, required): A brief description of the data source or file content (e.g., "My daily journal entries - Jan 2024", "Voice recording of project meeting"). Max length: 512 characters.
    *   `dataType` (String, optional): Client-provided MIME type of the file (e.g., `text/plain`, `audio/wav`). If not provided, the server will attempt to infer it. Max length: 128 characters.
    *   `consentTokenID` (UUID, required): The ID of a pre-existing `ConsentLedgerEntry` that explicitly authorizes the upload and processing of this specific data. This implies consent was obtained *before* this upload call.

*   **Response (Success - 202 Accepted):**
    Indicates that the file has been received and is queued for validation and processing.
    *   **Headers:**
        *   `Location`: URL to check the status of the processing, e.g., `/v1/users/{userID}/data/packages/{packageID}/status`
    *   **Body (JSON):**
        ```json
        {
          "packageID": "a1b2c3d4-e5f6-7890-1234-567890abcdef", // UUID generated by the server
          "userID": "user_uuid_placeholder_123",
          "fileName": "MyJournal_2023.txt", // Name of the uploaded file
          "fileSizeBytes": 102400,
          "dataTypeProvided": "text/plain",
          "status": "pending_validation_and_processing",
          "uploadTimestamp": "2024-03-15T10:30:00Z",
          "statusCheckURL": "/v1/users/{userID}/data/packages/a1b2c3d4-e5f6-7890-1234-567890abcdef/status"
        }
        ```
    *   **Schema for Success Response Body:**
        ```yaml
        type: object
        required:
          - packageID
          - userID
          - fileName
          - status
          - uploadTimestamp
          - statusCheckURL
        properties:
          packageID:
            type: string
            format: uuid
            description: Unique ID for the created UserDataPackage.
          userID:
            type: string
            format: uuid
            description: User ID who uploaded the data.
          fileName:
            type: string
            description: Original name of the uploaded file.
          fileSizeBytes:
            type: integer
            description: Size of the uploaded file in bytes.
          dataTypeProvided:
            type: string
            nullable: true
            description: MIME type provided by the client, if any.
          status:
            type: string
            enum: [pending_validation_and_processing, processing, completed, error] # Simplified status for this response
            description: Initial status of the data package.
          uploadTimestamp:
            type: string
            format: date-time
            description: Timestamp of the upload.
          statusCheckURL:
            type: string
            format: uri-reference
            description: URL to poll for the status of the data package processing.
        ```

*   **Common Error Responses:**
    *   `400 Bad Request`: Missing required form data, invalid UUID format, invalid `consentTokenID`.
        ```json
        { "error": { "code": 400, "message": "Validation failed.", "details": "Field 'sourceDescription' is required." } }
        ```
    *   `401 Unauthorized`: Invalid or missing Bearer Token.
    *   `403 Forbidden`: User is not authorized to upload data (e.g., `userID` in path does not match token, or `consentTokenID` is invalid or does not grant upload permission for this data).
    *   `413 Payload Too Large`: File size exceeds configured limits.
    *   `422 Unprocessable Entity`: `consentTokenID` is valid but does not cover the scope of this data upload.
    *   `500 Internal Server Error`: Unexpected server error.

---

### 2. Data Source Connection API (Conceptual)

Manages connections to third-party data sources like cloud storage services (Google Drive, Dropbox) or social media platforms. This involves OAuth 2.0 flows.

#### Endpoint: `GET /v1/users/{userID}/connections/oauth/{serviceName}/initiate`

*   **Description:** Initiates the OAuth 2.0 authorization flow for a supported third-party service.
*   **Authentication:** OAuth 2.0 Bearer Token (`Authorization: Bearer <user_access_token>`).
*   **Path Parameters:**
    *   `userID` (UUID, required): The EchoSphere user initiating the connection.
    *   `serviceName` (String, required): Identifier for the third-party service (e.g., `google-drive`, `twitter`, `dropbox`). Must be a pre-configured supported service.
*   **Query Parameters (Optional):**
    *   `redirect_uri_override` (String, optional): If the client needs to override the default redirect URI for the callback (must be from a pre-approved list for the client app).
*   **Response:**
    *   `302 Found`: Redirects the user's browser to the third-party OAuth provider's authorization URL. The `Location` header will contain this URL. The state parameter will be managed by UDIM to prevent CSRF.

#### Endpoint: `GET /v1/connections/oauth/{serviceName}/callback`

*   **Description:** Handles the OAuth 2.0 callback from the third-party provider after the user grants or denies authorization. This endpoint is called by the user's browser via redirect from the OAuth provider.
*   **Authentication:** No direct Bearer Token. Relies on the `state` parameter for CSRF protection and session correlation.
*   **Path Parameters:**
    *   `serviceName` (String, required): Identifier for the third-party service.
*   **Query Parameters (from OAuth Provider):**
    *   `code` (String, required if successful): The authorization code.
    *   `state` (String, required): The state parameter EchoSphere sent in the initiation step.
    *   `error` (String, optional): Error code if authorization failed at the provider.
    *   `error_description` (String, optional): Description of the error.
*   **Core Logic:**
    1.  Validate the `state` parameter.
    2.  If `code` is present, exchange it with the OAuth provider for an access token and (if applicable) a refresh token.
    3.  Securely store the tokens, associating them with the `userID` (retrieved from the validated `state` or session) and `serviceName`. This creates a "Connection."
    4.  Potentially, create an initial `ConsentLedgerEntry` for basic API access granted by the OAuth flow (e.g., permission to list files). More granular consent will be needed for specific data imports.
*   **Response (Success):**
    *   Usually a redirect (302) to a user-facing page in the EchoSphere application indicating success (e.g., "Google Drive connected successfully! You can now import data.") or failure.
    *   Alternatively, can return a JSON response if client is a Single Page Application (SPA).
        ```json
        {
          "connectionID": "conn_uuid_placeholder_987",
          "serviceName": "google-drive",
          "status": "connected",
          "message": "Successfully connected to Google Drive. You can now initiate data imports."
        }
        ```
*   **Response (Error):**
    *   Redirect to an error page or JSON error object if `state` is invalid, `error` parameter is present, or token exchange fails.

#### Endpoint: `POST /v1/users/{userID}/connections/{connectionID}/import`

*   **Description:** Allows an authenticated user to select and import specific data items from an already connected third-party source. This is an asynchronous operation.
*   **Authentication:** OAuth 2.0 Bearer Token.
*   **Path Parameters:**
    *   `userID` (UUID, required): The EchoSphere user.
    *   `connectionID` (UUID, required): The ID of the established connection (obtained after successful OAuth callback).
*   **Request Body (JSON):**
    *   **Schema:**
        ```yaml
        type: object
        required:
          - itemsToImport
          - consentTokenID
        properties:
          itemsToImport:
            type: array
            minItems: 1
            items:
              type: object
              required:
                - itemID_external # ID of the item in the external service
                - sourceDescription
              properties:
                itemID_external:
                  type: string
                  description: Unique identifier of the item within the third-party service (e.g., Google Drive file ID).
                sourceDescription:
                  type: string
                  description: Description of the item being imported (e.g., original filename).
                dataType: # Optional, server can attempt to infer
                  type: string
                  description: Expected MIME type or data category.
                metadata_override: # Optional
                  type: object
                  description: Any metadata client wants to pass to be stored in UserDataPackage.metadata
          consentTokenID:
            type: string
            format: uuid
            description: UUID of the ConsentLedgerEntry that authorizes the import of these specific items.
        ```
    *   **Example Request Body:**
        ```json
        {
          "itemsToImport": [
            {
              "itemID_external": "google_drive_file_id_1",
              "sourceDescription": "Project Alpha Notes.gdoc",
              "dataType": "application/vnd.google-apps.document"
            },
            {
              "itemID_external": "google_drive_file_id_2",
              "sourceDescription": "Meeting Audio Recording.mp3",
              "dataType": "audio/mpeg"
            }
          ],
          "consentTokenID": "consent_uuid_for_this_import_op"
        }
        ```
*   **Response (Success - 202 Accepted):**
    Indicates the import request has been acknowledged and items are being queued for fetching and processing.
    *   **Body (JSON):**
        ```json
        {
          "importJobID": "import_job_uuid_placeholder_123",
          "userID": "user_uuid_placeholder_123",
          "connectionID": "conn_uuid_placeholder_987",
          "requestedItemCount": 2,
          "status": "queued_for_import",
          "timestamp": "2024-03-15T11:00:00Z",
          "details": [ // Provides initial packageIDs, actual data fetching happens async
            { "itemID_external": "google_drive_file_id_1", "packageID": "pkg_uuid_1", "status": "pending_fetch" },
            { "itemID_external": "google_drive_file_id_2", "packageID": "pkg_uuid_2", "status": "pending_fetch" }
          ]
        }
        ```
*   **Error Responses:**
    *   `400 Bad Request`: Invalid request body structure, missing `itemsToImport` or `consentTokenID`.
    *   `401 Unauthorized` / `403 Forbidden`: Token issues or `connectionID` not valid for the user.
    *   `404 Not Found`: `connectionID` does not exist.
    *   `422 Unprocessable Entity`: `consentTokenID` invalid or does not cover the scope of importing these items. OAuth tokens for the connection might be expired/revoked requiring re-authentication.

---

## II. Internal APIs (Service-to-Service)

These APIs are used for communication between UDIM and other backend services within EchoSphere. They are not exposed externally.

### 1. Notify MAIPP API (Called by UDIM)

*   **Endpoint:** `POST /internal/maipp/v1/data-ready` (Logical endpoint for MAIPP service)
*   **Description:** UDIM calls this API to notify the AI Persona Analysis & Trait Extraction (MAIPP) module that a new `UserDataPackage` has been successfully ingested, encrypted, stored, and is ready for processing.
*   **Authentication:** Secure internal service-to-service authentication (e.g., mTLS, or a JWT signed by an internal EchoSphere token authority, passed in `Authorization` header).
*   **Request Body (JSON):**
    *   **Schema:**
        ```yaml
        type: object
        required:
          - packageID
          - userID
          - consentTokenID
          - rawDataReference
          - dataType
        properties:
          packageID:
            type: string
            format: uuid
            description: The ID of the UserDataPackage that is ready.
          userID:
            type: string
            format: uuid
            description: The ID of the user this data belongs to.
          consentTokenID:
            type: string
            format: uuid
            description: The ID of the consent token authorizing processing.
          rawDataReference:
            type: string
            description: Secure reference (e.g., S3 URI) to the encrypted data.
          dataType:
            type: string
            description: The data type/MIME type of the raw data.
          sourceDescription:
             type: string
             description: Description of the data source.
          metadata:
            type: object
            nullable: true
            description: Additional metadata associated with the data package.
        ```
    *   **Example Request Body:**
        ```json
        {
          "packageID": "a1b2c3d4-e5f6-7890-1234-567890abcdef",
          "userID": "user_uuid_placeholder_123",
          "consentTokenID": "consent_uuid_placeholder_789",
          "rawDataReference": "s3://echosphere-user-data-bucket/user_uuid_placeholder_123/a1b2c3d4-e5f6-7890-1234-567890abcdef/ResearchPaper_AI_Ethics.pdf.enc",
          "dataType": "application/pdf",
          "sourceDescription": "Direct Upload: ResearchPaper_AI_Ethics.pdf",
          "metadata": {
            "originalFilename": "ResearchPaper_AI_Ethics.pdf",
            "fileSizeBytes": 2048576
          }
        }
        ```
*   **Response (Success):**
    *   `200 OK`: MAIPP acknowledges receipt and has successfully queued the task.
    *   `202 Accepted`: MAIPP acknowledges receipt and will process it, but queuing was asynchronous.
    *   **Body (JSON - Optional):**
        ```json
        {
          "message": "MAIPP notified successfully. Package processing queued.",
          "maippProcessingID": "maipp_job_uuid_placeholder_456"
        }
        ```
*   **Error Handling:**
    *   If MAIPP is unavailable or returns an error (e.g., 5xx), UDIM should implement a retry mechanism with exponential backoff.
    *   After several failed retries, the message should be sent to a dead-letter queue (DLQ) for investigation. The `UserDataPackage` status should be updated to 'error_notification_failed'.

---

### 2. Consent Verification API (Called by UDIM and other internal services)

*   **Endpoint:** `GET /internal/consent/v1/verify` (Logical endpoint for UCMS or Consent Ledger Service)
*   **Description:** Verifies if a valid and appropriate consent exists for a given user, data, and requested scope of action. UDIM would call this before processing an upload or import to ensure the provided `consentTokenID` is valid for the operation.
*   **Authentication:** Secure internal service-to-service authentication.
*   **Request Parameters (Query String):**
    *   `userID` (UUID, required): The ID of the user whose consent is being verified.
    *   `consentTokenID` (UUID, optional): If checking a specific consent grant. If not provided, the service might check for any valid consent matching other parameters.
    *   `dataHash` (String, optional): SHA-256 hash of the data for which consent is being checked.
    *   `requiredScope` (String, required): A structured string or JSON representation of the permission(s) needed (e.g., `data:upload:text/plain`, `data:process:application/pdf:trait_extraction`). The exact format depends on the `consentScope` definition in `ConsentLedgerEntry`.
    *   `purpose` (String, optional): The purpose for which consent is being verified.
*   **Response (Success - 200 OK):**
    *   **Body (JSON):**
        ```json
        {
          "isValid": true, // boolean: true if consent is valid, false otherwise
          "consentTokenID": "consent_uuid_placeholder_789", // ID of the consent record that satisfied the request
          "scopeGranted": [ // The actual scope(s) granted by this token relevant to the request
            {
              "resourceType": "data_category",
              "resourceIdentifier": "application/pdf_user_uploads",
              "actions": ["read_raw", "decrypt_for_processing", "extract_text_content", "analyze_for_linguistic_traits"],
              // ...
            }
          ],
          "expires": "2025-03-15T10:25:00Z", // null if no expiration
          "isRevoked": false
        }
        ```
    *   If `isValid` is `false`, other fields might be omitted or indicate the reason (e.g., `reason_for_invalidity: "revoked"` or `"scope_not_sufficient"`).
    *   **Schema for Response Body:**
        ```yaml
        type: object
        required:
          - isValid
        properties:
          isValid:
            type: boolean
            description: True if a valid, non-revoked, non-expired consent covering the required scope exists.
          consentTokenID:
            type: string
            format: uuid
            nullable: true
            description: The ID of the specific consent grant that was validated.
          scopeGranted:
            type: array # Or object, depending on how scope is structured
            nullable: true
            description: Details of the scope(s) actually granted by the validated consent token relevant to the query.
          expires:
            type: string
            format: date-time
            nullable: true
            description: Expiration timestamp of the consent, if applicable.
          isRevoked:
            type: boolean
            nullable: true # Only relevant if a specific token was checked
            description: Indicates if the specific consent token checked has been revoked.
          reason_for_invalidity:
            type: string
            nullable: true
            description: A brief reason if isValid is false (e.g., 'not_found', 'expired', 'revoked', 'scope_insufficient').
        ```
*   **Error Handling:**
    *   `400 Bad Request`: Missing or invalid required query parameters.
    *   `404 Not Found`: `userID` or `consentTokenID` (if provided) does not exist.
    *   `500 Internal Server Error`: Error within the consent service.
```
