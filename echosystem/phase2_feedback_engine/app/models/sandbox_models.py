# echosystem/phase2_feedback_engine/app/models/sandbox_models.py
from pydantic import BaseModel, Field, HttpUrl # Ensure HttpUrl is imported
from typing import Optional, Dict, Any, List, Literal
import uuid
from datetime import datetime, timezone # Ensure timezone for default factory

class SandboxRequest(BaseModel):
    persona_id: uuid.UUID
    # ID of the specific PersonaBehavioralModel version to test
    behavioral_model_version_id: uuid.UUID
    # Scenarios or contexts to test against (could be simple text prompts or structured scenarios)
    test_scenarios: List[Dict[str, Any]] = Field(..., min_length=1) # Changed min_items to min_length for Pydantic v2
    # Desired sandbox configuration (conceptual, V-Architect would interpret these)
    sandbox_config_preferences: Optional[Dict[str, Any]] = Field(None, description="e.g., preferred_region, compute_tier")
    # Callback URL for V-Architect to notify when sandbox is ready/results are available
    callback_url: Optional[HttpUrl] = None # HttpUrl will validate the URL

class SandboxInstanceDetails(BaseModel):
    sandbox_id: uuid.UUID # ID generated by V-Architect or this service
    persona_id: uuid.UUID
    behavioral_model_version_id: uuid.UUID
    status: Literal["provisioning", "ready", "running_tests", "completed", "error", "terminating", "terminated"]
    # How to access the sandbox if direct interaction is needed (e.g., temp URL, API endpoint)
    access_endpoint: Optional[HttpUrl] = None
    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc)) # Added default factory
    expires_at: Optional[datetime] = None # Sandboxes might be time-limited
    error_message: Optional[str] = None
    # Optional: Store results or a link to results if tests are run by V-Architect
    test_results_summary: Optional[Dict[str, Any]] = None

    model_config = { # Pydantic V2 config
        "json_encoders": {
            uuid.UUID: str,
            datetime: lambda dt: dt.isoformat()
        },
        "populate_by_name": True,
        "arbitrary_types_allowed": True
    }

class SandboxCreationResponse(BaseModel):
    message: str
    sandbox_details: SandboxInstanceDetails

    model_config = SandboxInstanceDetails.model_config # Reuse for consistency

class SandboxStatusResponse(SandboxInstanceDetails): # Inherits all fields and model_config
    pass

class SandboxTerminationRequest(BaseModel): # Added for explicit termination payload if needed
    force_terminate: bool = False # Example field

class SandboxTerminationResponse(BaseModel):
    sandbox_id: uuid.UUID
    status: Literal["terminating", "terminated", "error", "not_found"] # Added not_found
    message: str

    model_config = SandboxInstanceDetails.model_config # Reuse for consistency
